image:
  repository: mesosphere/kommander
  tag: 1.116.17
  pullPolicy: IfNotPresent
replicas: 1
logoutRedirectPath: /ops/landing
clusterPollingInterval: 3000
clientPollingInterval: 3000


# Mode must be either production|konvoy
mode: production

displayName: Konvoy Cluster

# Konvoy ui should NOT create the CRD if Kommander already did it
createObservableClusterCRD: true

extraInitContainers:

resources:
  requests:
    memory: "128Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "2000m"

readinessProbe:
  initialDelaySeconds: 15
  periodSeconds: 3
livenessProbe:
  initialDelaySeconds: 15
  periodSeconds: 3

### This must match the serviceName set in the ingress backend below
service:
  name: kommander

ingress:
  traefikFrontendRuleType: PathPrefixStrip
  extraAnnotations:
    traefik.ingress.kubernetes.io/priority: "1"
    traefik.ingress.kubernetes.io/auth-type: forward
    traefik.ingress.kubernetes.io/auth-url: http://traefik-forward-auth-kubeaddons.kubeaddons.svc.cluster.local:4181/
    traefik.ingress.kubernetes.io/auth-response-headers: X-Forwarded-User
  path: /ops/portal/kommander

federate:
  addons: true
  roles: true
  rolebindings: true
  clusterrolebindings: true

# This name must match the name of the kubefed dep
# in order to override values.
kubefed:
  # set to false if you wish to run kommander without deploying kubefed (not recommended)
  enabled: true
  controllermanager:
    # override value is necessary due to a "featureGates":interface {}(nil)... spec.featureGates in body must be of type array: "null"
    # bug found
    featureGates:
      CrossClusterServiceDiscovery: "Disabled"
      FederatedIngress: "Disabled"
      PushReconciler: "Enabled"
      SchedulerPreferences: "Disabled"

kommander-cluster-lifecycle:
  enabled: true

  konvoy:
    version: v1.1.5

  certificates:
    issuer:
      name:
      kind: Issuer
      selfSigned: false

grafana:
  enabled: true

  ## Do not deploy default dashboards.
  ##
  defaultDashboardsEnabled: false

  adminPassword: prom-operator

  ## Grafana's primary configuration
  ## NOTE: values in map will be converted to ini format
  ## ref: http://docs.grafana.org/installation/configuration/
  ##
  grafana.ini:
    server:
      protocol: http
      enable_gzip: true
      root_url: "%(protocol)s://%(domain)s:%(http_port)s/kommander/grafana"
    auth.proxy:
      enabled: true
      header_name: X-Forwarded-User
      auto-sign-up: true
    auth.basic:
      enabled: false
    users:
      auto_assign_org_role: Admin

  ingress:
    ## If true, Grafana Ingress will be created
    ##
    enabled: true

    ## Annotations for Grafana Ingress
    ##
    annotations:
      kubernetes.io/ingress.class: "traefik"
      traefik.frontend.rule.type: "PathPrefixStrip"
      traefik.ingress.kubernetes.io/auth-response-headers: "X-Forwarded-User"
      traefik.ingress.kubernetes.io/auth-type: "forward"
      traefik.ingress.kubernetes.io/auth-url: "http://traefik-forward-auth-kubeaddons.kubeaddons.svc.cluster.local:4181/"
      traefik.ingress.kubernetes.io/priority: "2"

    ## Labels to be added to the Ingress
    ##
    labels: {}

    ## Hostnames.
    ## Must be provided if Ingress is enable.
    ##
    # hosts:
    #   - grafana.domain.com
    hosts:
      - ""

    ## Path for grafana ingress
    path: /kommander/grafana

    ## TLS configuration for grafana Ingress
    ## Secret must be manually created in the namespace
    ##
    tls: []
    # - secretName: grafana-general-tls
    #   hosts:
    #   - grafana.example.com

  ## Configure grafana datasources
  ## ref: http://docs.grafana.org/administration/provisioning/#datasources
  ##
  datasources:
    datasources.yaml:
      apiVersion: 1
      datasources:
      - name: ThanosQuery
        type: prometheus
        url: http://kommander-kubeaddons-thanos-query-http:10902/
        access: proxy
        isDefault: true

  ## Sidecars that collect the configmaps with specified label and stores the included files them into the respective folders
  ## Requires at least Grafana 5 to work and can't be used together with parameters dashboardProviders, datasources and dashboards
  sidecar:
    dashboards:
      enabled: true
      # label that the configmaps with dashboards are marked with
      label: grafana_dashboard_kommander
    datasources:
      enabled: true
      defaultDatasourceEnabled: false
      # label that the configmaps with datasources are marked with
      label: grafana_datasource_kommander
      # If specified, the sidecar will search for datasource config-maps inside this namespace.
      # Otherwise the namespace in which the sidecar is running will be used.
      # It's also possible to specify ALL to search in all namespaces
      searchNamespace: null

  extraConfigmapMounts: []
  # - name: certs-configmap
  #   mountPath: /etc/grafana/ssl/
  #   configMap: certs-configmap
  #   readOnly: true

  ## Configure additional grafana datasources
  ## ref: http://docs.grafana.org/administration/provisioning/#datasources
  additionalDataSources: []
  # - name: prometheus-sample
  #   access: proxy
  #   basicAuth: true
  #   basicAuthPassword: pass
  #   basicAuthUser: daco
  #   editable: false
  #   jsonData:
  #       tlsSkipVerify: true
  #   orgId: 1
  #   type: prometheus
  #   url: https://prometheus.svc:9090
  #   version: 1

  ## If true, create a serviceMonitor for grafana
  ##
  serviceMonitor:
    ## Scrape interval. If not set, the Prometheus default scrape interval is used.
    ##
    interval: ""
    selfMonitor: true

    ##  metric relabel configs to apply to samples before ingestion.
    ##
    metricRelabelings: []
    # - action: keep
    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'
    #   sourceLabels: [__name__]

    #   relabel configs to apply to samples before ingestion.
    ##
    relabelings: []
    # - sourceLabels: [__meta_kubernetes_pod_node_name]
    #   separator: ;
    #   regex: ^(.*)$
    #   target_label: nodename
    #   replacement: $1
    #   action: replace

thanos:
  enabled: true

  image:
    repository: thanosio/thanos
    tag: v0.4.0
    pullPolicy: IfNotPresent

  store:
    enabled: false

  query:
    enabled: true
    # Label to treat as a replica indicator along which data is deduplicated.
    # Still you will be able to query without deduplication using 'dedup=false' parameter.
    replicaLabel: ""
    # Prefix for API and UI endpoints. This allows thanos UI to be served on a sub-path.
    # This option is analogous to --web.route-prefix of Promethus.
    webRoutePrefix: ""
    # Static prefix for all HTML links and redirect
    #  URLs in the UI query web interface. Actual
    #  endpoints are still served on / or the
    #  web.route-prefix. This allows thanos UI to be
    #  served behind a reverse proxy that strips a URL
    #  sub-path.
    webExternalPrefix: ""
    # Name of HTTP request header used for dynamic prefixing of UI links and redirects.
    # This option is ignored if web.external-prefix argument is set. Security risk: enable this
    # option only if a reverse proxy in front of thanos is resetting the header. The --web.prefix-header=X-Forwarded-Prefix option
    # can be useful, for example, if Thanos UI is served via Traefik reverse proxy with PathPrefixStrip option enabled, which sends the
    # stripped prefix value in X-Forwarded-Prefix header. This allows thanos UI to be served on a sub-path
    webPrefixHeader: "X-Forwarded-Prefix"
    # https://github.com/improbable-eng/thanos/issues/1015
    storeDNSResolver: miekgdns
    # Enable DNS discovery for stores
    storeDNSDiscovery: false
    # Enable DNS discovery for sidecars (this is for the chart built-in sidecar service)
    sidecarDNSDiscovery: false
    # Addresses of statically configured store API servers (repeatable).
    # The scheme may be prefixed with 'dns+' or 'dnssrv+' to detect store API servers through respective DNS lookups.
    stores: []
    # Log filtering level.
    logLevel: info
    # Add extra environment variables to compact
    extraEnv: []
    # - name: ENV
    #   value: value
    #
    # Add extra arguments to the compact service
    extraArgs: []
    # - "--extraargs=extravalue"
    #
    # Number of replicas running from query component
    replicaCount: 1
    # The grpc endpoint to communicate with other components
    grpc:
      # grpc listen port number
      port: 10903
      # Service definition for query grpc service
      service:
        # Annotations to query grpc service
        annotations: {}
      # Set up ingress for the grpc service
      ingress:
        enabled: false
        annotations: {}
        # kubernetes.io/ingress.class: nginx
        # kubernetes.io/tls-acme: "true"
        labels: {}
        path: "/"
        hosts:
        - "/"
        tls: []
        #  - secretName: chart-example-tls
        #    hosts:
        #      - chart-example.local
    serviceAccount: ""

    # The http endpoint to communicate with other components
    http:
      # http listen port number
      port: 10902
      # Service definition for query http service
      service:
        type: ClusterIP
        # Annotations to query http service
        annotations: {}
      # Set up ingress for the http service
      ingress:
        enabled: true
        annotations:
          kubernetes.io/ingress.class: "traefik"
          traefik.frontend.rule.type: "PathPrefixStrip"
          traefik.ingress.kubernetes.io/auth-response-headers: "X-Forwarded-User"
          traefik.ingress.kubernetes.io/auth-type: "forward"
          traefik.ingress.kubernetes.io/auth-url: "http://traefik-forward-auth-kubeaddons.kubeaddons.svc.cluster.local:4181/"
          traefik.ingress.kubernetes.io/priority: "2"
        labels: {}
        path: "/kommander/query"
        hosts:
        - ""
        tls: []
        #  - secretName: chart-example-tls
        #    hosts:
        #      - chart-example.local

    certSecretName: ""
    # Extra labels for query pod template
    labels: {}
    #  cluster: example
    #
    # Extra annotations for compact pod template
    annotations: {}
    #  example.com: default
    #
    # Add extra labels to compact deployment
    deploymentLabels: {}
    #  extraLabel: extraLabelValue
    #
    # Add extra annotations to compact deployment
    deploymentAnnotations: {}
    #  extraAnnotation: extraAnnotationValue
    #
    # Enable metrics collecting for compat service
    metrics:
      # This is the Prometheus annotation type scraping configuration
      annotations:
        enabled: false
      # Enable ServiceMonitor https://github.com/coreos/prometheus-operator
      serviceMonitor:
        enabled: true

    # Optional securityContext
    securityContext: {}
    resources: {}
    #  limits:
    #    cpu: 2000m
    #    memory: 16Gi
    #  requests:
    #    cpu: 1000m
    #    memory: 4Gi
    #
    # Node tolerations for server scheduling to nodes with taints
    # Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
    #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
    #
    # Node labels for compact pod assignment
    # Ref: https://kubernetes.io/docs/user-guide/node-selection/
    #
    nodeSelector: {}
    #
    # Pod affinity
    # Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#node-affinity
    affinity: {}

  compact:
    enabled: false

  bucket:
    enabled: false

karma:
  enabled: true

  image:
    repository: lmierzwa/karma
    tag: v0.44
    pullPolicy: IfNotPresent

  env:
   - name: ALERTMANAGER_URI
     value: ""

  service:
    type: ClusterIP
    port: 80
    annotations: {}
    # prometheus.io/scrape: "true"

  serviceAccount:
    # Specifies whether a ServiceAccount should be created
    create: true
    # The name of the ServiceAccount to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: "traefik"
      traefik.ingress.kubernetes.io/auth-response-headers: "X-Forwarded-User"
      traefik.ingress.kubernetes.io/auth-type: "forward"
      traefik.ingress.kubernetes.io/auth-url: "http://traefik-forward-auth-kubeaddons.kubeaddons.svc.cluster.local:4181/"
      traefik.ingress.kubernetes.io/priority: "2"
    labels: {}
    path: "/kommander/karma"
    hosts:
    - ""
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #  cpu: 100m
    #  memory: 128Mi
    # requests:
    #  cpu: 100m
  #  memory: 128Mi

  # configuration for liveness probe
  livenessProbe:
    delay: 5
    period: 5
    path: /kommander/karma/

  # configMap dictates if a configmap based configuration for Karma should be used
  # to provide advanced configuration. NOTE, you must use port 8080!
  configMap:
    enabled: true
    rawConfig:
      alertmanager:
        interval: 30s
        servers:
          - name: kommander
            uri: http://prometheus-kubeaddons-prom-alertmanager.kubeaddons:9093/
            timeout: 10s
            tls:
              insecureSkipVerify: true
      listen:
        address: "0.0.0.0"
        port: 8080
        prefix: /kommander/karma/
